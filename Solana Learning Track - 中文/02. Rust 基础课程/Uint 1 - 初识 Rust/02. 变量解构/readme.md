# Content/概念

**变量解构**是一种将复合数据类型（如元组、结构体、枚举等）中的值分解为单独变量的过程。它可以方便地从复杂的数据结构中提取出需要的值，并以更简洁的方式进行操作。通过这种方式，可以更好的控制数据的可见性，也使得代码更加优雅。

变量解构通俗来讲就是已知原有的结构，解开该结构。它并不是 Rust 独有的特性，Python、JavaScript、Solidity等许多编程语言也都有。

- 比喻
    
    变量解构是一种从复杂数据结构中提取信息的方式，比如说你有1个装满了各种水果的篮子，有香蕉、菠萝和榴莲，这里面的每种水果相当于元组中的一个元素，你可以使用变量解构来将篮子中的每种水果放在不同的盘子里，当然，不喜欢榴莲的话，只放香蕉和菠萝就行了。
    变量解构其实跟“奥卡姆剃刀原则”有着哲学层面的共通之处，通过变量解构中我们可以在复杂的数据类型中只关注那些我们用到的变量，对其他变量直接忽略掉，这难道不是奥卡姆剃刀中的“如无必要，勿增实体”么？
    
- 真实用例
    
    solana 中通过`find_program_address`函数计算 PDA 账户（一种由主程序衍生的没有私钥的账户），返回值为包含2个元素的元素，我们可以根据需要决定是否接收第2个元素：
    
    ```rust
    // 根据签名用户数组 和 程序ID 获取对应的 PDA 账户 及 bump 跳值种子
    let (pda_account, bump_seed) = Pubkey::find_program_address(&[singer.key.as_ref()], program_id);
    
    // 如果不需要第2个元素，可以用 _ 代替
    let (pda_account, _) = Pubkey::find_program_address(&[singer.key.as_ref()], program_id);
    ```
    

### Documentation

我们可以通过如下的方式，把水果篮里的香蕉、菠萝、榴莲放在a、b、c三个不同的盘子里，或者换一种方式，只拿香蕉和菠萝。

```solidity
// 第一种放法
let (a, b, c) = ("Banana", "pineapple", "durian");

// 第二种放法
let (e, d, _) = ("Banana", "pineapple", "durian");
```

### FAQ

- Q：变量解构一般适用于哪些复杂的数据类型？
    
    A：①元组类型，它是将多个不同类型的值组合在一起的数据结构，例如，`(1, "hello", 3.14)` ；
    
    ②数组类型，它是多个同种类型的值组合在一起的数据结构，例如：`[1, 2, 3, 4]`；
    
    ③结构体类型，它是一种自定义的数据类型，用于将不同类型的数据组合在一起形成一个新的结构，例如：
    
    ```solidity
    // 这是一只可爱的小螃蟹
    struct Ferris {
        id_number: i32,
        name: String,
    }
    ```
    
    在后续的章节，我们会对这些类型进行专门的介绍，这里大家有个初步印象即可。
    

# Example/示例代码

我们通过元组、数组、结构体的数据类型分别演示下如何进行解构式赋值，只获取我们关心的字段。（这些数据类型在第三章会有详细介绍）

```solidity
struct Ferris {
    e: i32,
    f: String
}

fn main() {
    let (a, b, c, d, e, f);

    // 元组解构
    (a, b) = (1, 2);
    // 数组解构，..表示忽略多个元素，_表示忽略对应索引位置的元素（1个）
    [c, .., d, _] = [1, 2, 3, 4, 5];
    // 结构体解构
    Ferris { e, f } = Ferris { e:5, f:"rust".to_string() };

    assert_eq!((1, 2, 1, 4, 5, "rust".to_string()), (a, b, c, d, e, f));
}
```