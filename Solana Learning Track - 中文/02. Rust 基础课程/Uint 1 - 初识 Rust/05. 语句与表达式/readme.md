# Content/概念

**语句（Statements）**是Rust中的**执行单位**，它们执行一些操作但不返回值，以分号`;`结尾。

**表达式（Expressions）**是Rust中的**计算单位**，它们计算并返回一个值，所以表达式可以用作赋值。常见的表达式有函数调用、宏调用、用大括号创建的代码块等。

**单元类型**：是Rust 中一个特殊的返回值类型，意味着函数或表达式没有返回值，类似于其他语言中的`void`的返回类型。用符号 `()` 来表示。

> 小技巧：区分语句和表达式的一个简单方法就是有无分号`;`，有的话就是语句，执行操作但不返回结果；没有的话就是表达式，执行计算并返回结果。虽然这种方式在有些情况下不成立，但现阶段足以让我们应对绝大数场景。
> 
- 比喻
    
    在Rust，**语句**如厨师的动作，比如切菜、煮水、或者调味，执行任务但不产生最终产品，以分号结束。**表达式**则如成品菜肴，比如切好的蔬菜、煮好的汤，或者调配好的酱汁，计算并返回有用的结果，可被用于后续操作。语句是任务的执行者，表达式是计算的结果，二者共同构成程序的动态过程。
    
- 真实用例
    
    我们看下solana 的链上程序入口点函数（即程序的入口）：
    
    ```rust
    // 链上程序的执行入口
    pub fn process_instruction(
        program_id: &Pubkey,
        accounts: &[AccountInfo],
        instruction_data: &[u8]
    ) -> ProgramResult {
    
        // 这是一个语句
        msg!("Hello, world!");
    		
    		// ……具体逻辑省略
    
        // 这是一个表达式，返回类型为 Result::Ok，值为空 ()，即不需要返回值
        Ok(())
    }
    ```
    

### Documentation

我们通过下面的代码中展示下“语句”和“表达式”。

```rust
fn main() {
    // 语句，使用 let 关键字创建变量并绑定一个值
    let a = 1;

    // 语句不返回值，所以不能把语句(let a = 1)绑定给变量b，下面代码会编译失败
    let b = (let a = 1);
    
    // 表达式，返回值是 x + 1
    let y = {
        let x = 3;
        x + 1
    };
    
    println!("The value of y is: {}", y); // y = 4
}
```

### FAQ

# Example/示例代码

我们通过下面的例子学习下常见的语句、代码块{}表达式、单元类型返回值以及 if 表达式。

```solidity
fn main() {
    // 以下4个为语句
    let a = 1;
    let b: Vec<f64> = Vec::new(); // vec表示创建一个类型为f64的动态数组
    let (a, c) = ("hi", false);  // 元组类型
    let x: i32 = 5;

    // 这是代码块表达式
    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // 下面表达式的值将被赋给 `y`
        x_cube + x_squared + x
    };
    println!("y is {:?}", y);  // y = 155

    let z = {
        // 这是一个表达式，计算 x+1 的值并返回
        x + 1 

        // 如果加上分号(;)就变成了语句，无返回值
        // Rust中默认为“单元类型()”，此时 z = ()
        // x + 1; 
    };
    println!("z = {:?}", z);
    
    // if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回
    // 类似三元运算符，在Rust里我们可以这样写
    let p = if x % 2 == 1 {
        "odd"
    } else {
        "even"
    };
}
```