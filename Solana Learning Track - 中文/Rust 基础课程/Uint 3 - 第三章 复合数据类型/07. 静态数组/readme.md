# Content/概念

**数组**：是将多个**相同类型**的元素依次组合在一起，形成的集合。在 Rust 中常用的数组有两种，一种是直接分配在栈内存中，速度很快但是长度固定的静态数组 `array`，另一种则是分配在堆内存中，可动态增长，但有性能损耗的动态数组 `Vector`。

我们在之前的章节提到过“元组”，它跟数组最重要的区别就是它**不同类型**的元素集合，而数组是相同类型的元素。

这一节我们将介绍下“静态数组”相关的内容。

- 比喻
    
    静态数组就像购物篮，一开始就决定了能装多少物品；而动态数组则像购物袋，可以根据购物需求灵活伸缩。但前提是所有物品都是同一类型。
    
- 真实用例
    
    Solana 的地址（用公钥表示）通常是一个 32 字节的数组。可以通过 **`Pubkey`** 结构体中的 **`new_from_array`** 方法，可以从一个包含 32 个字节的数组创建一个新的 **`Pubkey`** 实例。
    
    ```rust
    // solana_program::pubkey::Pubkey
    
    // pubkey_array为 u8 类型的数组，长度为 32
    pub const fn new_from_array(pubkey_array: [u8; 32]) -> Self {
        Self(pubkey_array)
    }
    ```
    

### Documentation

如下代码展示了通过不同方式创建静态数组的语法

```solidity
// 不指定元素类型，由编译器推断
let a = [1, 2, 3, 4, 5];

// [类型;长度] 显式指定类型及长度
let b: [i32; 5] = [1, 2, 3, 4, 5];

// [初始值;长度] 初始化一个某个值重复出现 N 次的数组，c = [3,3,3,3,3]
let c = [3; 5];
```

### FAQ

# Example/示例代码

接下来我们学习下元素为非基础类型的数组的创建、数组的访问、越界以及二维数组的相关内容。

```solidity
fn main() {
    // array = [类型; 长度] 这种语法对于i32、f64、bool等基础类型是OK的
    let a = [3u8; 5]; // a = [3, 3, 3, 3, 3]

    // 但是对于String这类非基础类型，需要用如下方式，因为基础类型数据是在栈内存，可以直接拷贝，
    // 而非基础类型的数据是在堆内存，需要深拷贝。
    let b: [String; 3] = std::array::from_fn(|_i| String::from("rust")); // b = ["rust","rust","rust"]

    let c = [9, 8, 7, 6, 5];
    // 通过下标直接访问
    let first = c[0]; // first = 9
    let second = c[1]; // second = 8

    // 访问不存在的元素，编译器会直接识别到并给出错误提示
    // let none_element = c[100];

    // arrays是一个二维数组，其中每一个元素都是一个数组，元素类型是[u8; 5]
		// arrays = [[3, 3, 3, 3, 3],[9, 8, 7, 6, 5]]
    let arrays: [[u8; 5]; 2] = [a, c];
}
```