# Content

In the previous section, we delved into the `#[program]` macro, which encompasses all the instruction functions. In this section, we'll explore the instruction functions, using the `initialize` function as an example. Its first parameter is of type `Context`. What exactly is this type?

```rust
#[program]
mod anchor_counter {
    pub fn initialize(ctx: Context<InitializeAccounts>, instruction_data: u64) -> Result<()> {
        ctx.accounts.counter.count = instruction_data;
        Ok(())
    }
}
```

### Context Parameter Type

`Context` is a struct defined in the Anchor framework, designed to encapsulate context information related to Solana program execution. It ***includes instruction metadata and all the account information needed in the logic***. Its structure is as follows:

```rust
// anchor_lang::context
pub struct Context<'a, 'b, 'c, 'info, T> {
    /// Current program_id
    pub program_id: &'a Pubkey,
    /// Deserialized account collection 'accounts'
    pub accounts: &'b mut T,
    /// Accounts not included in 'accounts', it is an array type
    pub remaining_accounts: &'c [AccountInfo<'info>],
    /// ...
}
```

The `Context` uses the generic type `T` to specify the account collection required by the instruction function. In practical use, we need to specify the concrete type of generic T, such as `Context<InitializeAccounts>`, `Context<UpdateAccounts>`, etc. Through this parameter, the instruction function can access the following data:

- `ctx.program_id`: Program ID, the current address of the executing program. It is of type `Pubkey`.
- `ctx.accounts`: Account collection, its type is the concrete type specified by generic T, such as the account collection required for initialization `InitializeAccounts` or the account collection required for an update `UpdateAccounts`, generated by the derived macro `#[derive(Accounts)]`. Anchor framework automatically performs deserialization.
- `ctx.remaining_accounts`: Remaining account collection, including accounts not explicitly declared by `#[derive(Accounts)]` in the current instruction. It provides a flexible way for the program to handle accounts that are not certain at the time of writing the program or dynamically created during execution. The accounts in this collection do not support direct deserialization and need manual handling.

### Context<T> Generic T

Let's take a look at the generic T of the first instruction function: `InitializeAccounts`. This account collection has 3 accounts. The first one is the data account `pda_counter`, which is a derived account for storing counter data. The second parameter is the account `user` signing the transaction and paying the transaction fee. The third parameter is the Solana system account `system_program`, required because PDA accounts need to be generated by the system program.

```rust
#[derive(Accounts)]
pub struct InitializeAccounts<'info> {
    // PDA account
    #[account(init, seeds = [b"my_seed", user.key.to_bytes().as_ref()], payer = user, space = 8 + 8)]
    pub pda_counter: Account<'info, Counter>,
    // Transaction signing account
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

```

Due to space constraints, details about the types and attributes of these accounts will be covered in the next section.

### Instruction Parameters (Optional)

In the Anchor framework, the first parameter `ctx` of the instruction function is **mandatory**, while the second parameter, which is optional, represents additional data passed during the execution of the instruction function. Whether it is needed depends on the specific logic and requirements of the instruction. In the `initialize` function, it is used to initialize the initial value of the counter. In contrast, the `increment` function does not require additional data, so it only has the `ctx` parameter.

<aside>
ðŸ’¡ In summary, the purpose of the **`Context`** struct is to provide developers with a convenient way to access information related to program execution. By organizing this information in a struct, it becomes clearer to manage and access contextual information without having to pass a large number of individual parameters in function arguments.

</aside>

# Example

The complete program code is shown here.

```rust
//Introduce the pre-import module of the anchor framework
use anchor_lang::prelude::*;

//The on-chain address of the program
declare_id!("3Vg9yrVTKRjKL9QaBWsZq4w7UsePHAttuZDbrZK3G5pf");

//Instruction processing logic
#[program]
mod anchor_counter {
     use super::*;
     pub fn initialize(ctx: Context<InitializeAccounts>, instruction_data: u64) -> Result<()> {
         ctx.accounts.counter.count = instruction_data;
         Ok(())
     }

     pub fn increment(ctx: Context<UpdateAccounts>) -> Result<()> {
         let counter = &mut ctx.accounts.counter;
         msg!("Previous counter: {}", counter.count);
         counter.count = counter.count.checked_add(1).unwrap();
         msg!("Counter incremented. Current count: {}", counter.count);
         Ok(())
     }
}

//The set of accounts involved in the instruction
#[derive(Accounts)]
pub struct InitializeAccounts<'info> {
     #[account(init, seeds = [b"my_seed", user.key.to_bytes().as_ref()], payer = user, space = 8 + 8)]
     pub pda_counter: Account<'info, Counter>,
     #[account(mut)]
     pub user: Signer<'info>,
     pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UpdateAccounts<'info> {
     #[account(mut)]
     pub counter: Account<'info, Counter>,
     pub user: Signer<'info>,
}

// Custom account type
#[account]
pub struct Counter {
     count: u64
}
```